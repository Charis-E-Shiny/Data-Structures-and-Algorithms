/**
 * DNA Chain CLI Lab
 * 
 * This program implements a linked list to represent DNA sequences.
 * It provides a command-line interface for manipulating DNA chains.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Define the structure for a DNA node
typedef struct DNANode {
    char nucleotide;           // A, T, G, or C
    struct DNANode* next;      // Pointer to the next node
    struct DNANode* prev;      // Pointer to the previous node (for double-linked list)
} DNANode;

// Define the structure for a DNA chain
typedef struct {
    DNANode* head;             // Pointer to the first node
    DNANode* tail;             // Pointer to the last node
    int length;                // Length of the DNA chain
} DNAChain;

// Function declarations
DNAChain* createDNAChain();
void freeDNAChain(DNAChain* chain);
int appendNucleotide(DNAChain* chain, char nucleotide);
int insertNucleotide(DNAChain* chain, char nucleotide, int position);
int deleteNucleotide(DNAChain* chain, int position);
void displayDNAChain(DNAChain* chain);
DNAChain* complementDNAChain(DNAChain* chain);
int validateNucleotide(char nucleotide);
void printHelp();
int loadFromFile(DNAChain* chain, const char* filename);
int saveToFile(DNAChain* chain, const char* filename);
void searchPattern(DNAChain* chain, const char* pattern);
void reverseChain(DNAChain* chain);

/**
 * Main function - implements the command-line interface
 */
int main() {
    DNAChain* chain = createDNAChain();
    DNAChain* complementChain = NULL;
    char command[20];
    char input[1000];
    char filename[100];
    char nucleotide;
    int position;
    int running = 1;
    
    printf("=== DNA Chain CLI Lab ===\n");
    printf("Type 'help' for available commands\n");
    
    while (running) {
        printf("\n> ");
        scanf("%s", command);
        
        // Convert command to lowercase
        for (int i = 0; command[i]; i++) {
            command[i] = tolower(command[i]);
        }
        
        // Process command
        if (strcmp(command, "append") == 0) {
            scanf(" %c", &nucleotide);
            nucleotide = toupper(nucleotide);
            if (appendNucleotide(chain, nucleotide)) {
                printf("Appended '%c' to the chain\n", nucleotide);
            } else {
                printf("Error: Invalid nucleotide. Use A, T, G, or C\n");
            }
        } 
        else if (strcmp(command, "insert") == 0) {
            scanf(" %c %d", &nucleotide, &position);
            nucleotide = toupper(nucleotide);
            if (insertNucleotide(chain, nucleotide, position)) {
                printf("Inserted '%c' at position %d\n", nucleotide, position);
            } else {
                printf("Error: Invalid nucleotide or position\n");
            }
        } 
        else if (strcmp(command, "delete") == 0) {
            scanf("%d", &position);
            if (deleteNucleotide(chain, position)) {
                printf("Deleted nucleotide at position %d\n", position);
            } else {
                printf("Error: Invalid position\n");
            }
        } 
        else if (strcmp(command, "display") == 0) {
            displayDNAChain(chain);
        } 
        else if (strcmp(command, "complement") == 0) {
            if (complementChain != NULL) {
                freeDNAChain(complementChain);
            }
            complementChain = complementDNAChain(chain);
            printf("Complement chain created:\n");
            displayDNAChain(complementChain);
        } 
        else if (strcmp(command, "load") == 0) {
            scanf("%s", filename);
            if (loadFromFile(chain, filename)) {
                printf("DNA chain loaded from %s\n", filename);
            } else {
                printf("Error loading from file %s\n", filename);
            }
        } 
        else if (strcmp(command, "save") == 0) {
            scanf("%s", filename);
            if (saveToFile(chain, filename)) {
                printf("DNA chain saved to %s\n", filename);
            } else {
                printf("Error saving to file %s\n", filename);
            }
        } 
        else if (strcmp(command, "search") == 0) {
            scanf("%s", input);
            for (int i = 0; input[i]; i++) {
                input[i] = toupper(input[i]);
            }
            searchPattern(chain, input);
        } 
        else if (strcmp(command, "reverse") == 0) {
            reverseChain(chain);
            printf("Chain reversed\n");
            displayDNAChain(chain);
        } 
        else if (strcmp(command, "clear") == 0) {
            freeDNAChain(chain);
            chain = createDNAChain();
            printf("Chain cleared\n");
        } 
        else if (strcmp(command, "length") == 0) {
            printf("Chain length: %d nucleotides\n", chain->length);
        } 
        else if (strcmp(command, "help") == 0) {
            printHelp();
        } 
        else if (strcmp(command, "exit") == 0 || strcmp(command, "quit") == 0) {
            running = 0;
            printf("Exiting DNA Chain CLI Lab...\n");
        } 
        else {
            printf("Unknown command. Type 'help' for available commands\n");
        }
    }
    
    // Clean up
    freeDNAChain(chain);
    if (complementChain != NULL) {
        freeDNAChain(complementChain);
    }
    
    return 0;
}

/**
 * Create a new DNA chain
 */
DNAChain* createDNAChain() {
    DNAChain* chain = (DNAChain*)malloc(sizeof(DNAChain));
    if (chain == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    
    chain->head = NULL;
    chain->tail = NULL;
    chain->length = 0;
    
    return chain;
}

/**
 * Free all memory associated with a DNA chain
 */
void freeDNAChain(DNAChain* chain) {
    if (chain == NULL) {
        return;
    }
    
    DNANode* current = chain->head;
    DNANode* next;
    
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    
    free(chain);
}

/**
 * Append a nucleotide to the end of the chain
 * Returns 1 on success, 0 on failure
 */
int appendNucleotide(DNAChain* chain, char nucleotide) {
    if (!validateNucleotide(nucleotide)) {
        return 0;
    }
    
    DNANode* newNode = (DNANode*)malloc(sizeof(DNANode));
    if (newNode == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    
    newNode->nucleotide = nucleotide;
    newNode->next = NULL;
    
    if (chain->head == NULL) {
        // Empty chain
        newNode->prev = NULL;
        chain->head = newNode;
        chain->tail = newNode;
    } else {
        // Append to the end
        newNode->prev = chain->tail;
        chain->tail->next = newNode;
        chain->tail = newNode;
    }
    
    chain->length++;
    return 1;
}

/**
 * Insert a nucleotide at a specific position
 * Returns 1 on success, 0 on failure
 */
int insertNucleotide(DNAChain* chain, char nucleotide, int position) {
    if (!validateNucleotide(nucleotide)) {
        return 0;
    }
    
    // Check if position is valid (0 to length)
    if (position < 0 || position > chain->length) {
        return 0;
    }
    
    // If position is at the end, use append
    if (position == chain->length) {
        return appendNucleotide(chain, nucleotide);
    }
    
    DNANode* newNode = (DNANode*)malloc(sizeof(DNANode));
    if (newNode == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    
    newNode->nucleotide = nucleotide;
    
    if (position == 0) {
        // Insert at the beginning
        newNode->next = chain->head;
        newNode->prev = NULL;
        chain->head->prev = newNode;
        chain->head = newNode;
    } else {
        // Insert at position
        DNANode* current = chain->head;
        int i = 0;
        
        while (i < position - 1) {
            current = current->next;
            i++;
        }
        
        newNode->next = current->next;
        newNode->prev = current;
        current->next->prev = newNode;
        current->next = newNode;
    }
    
    chain->length++;
    return 1;
}

/**
 * Delete a nucleotide at a specific position
 * Returns 1 on success, 0 on failure
 */
int deleteNucleotide(DNAChain* chain, int position) {
    // Check if position is valid (0 to length-1)
    if (position < 0 || position >= chain->length || chain->head == NULL) {
        return 0;
    }
    
    DNANode* nodeToDelete;
    
    if (position == 0) {
        // Delete the first node
        nodeToDelete = chain->head;
        chain->head = chain->head->next;
        
        if (chain->head == NULL) {
            // Chain is now empty
            chain->tail = NULL;
        } else {
            chain->head->prev = NULL;
        }
    } else if (position == chain->length - 1) {
        // Delete the last node
        nodeToDelete = chain->tail;
        chain->tail = chain->tail->prev;
        chain->tail->next = NULL;
    } else {
        // Delete node at position
        DNANode* current = chain->head;
        int i = 0;
        
        while (i < position) {
            current = current->next;
            i++;
        }
        
        nodeToDelete = current;
        current->prev->next = current->next;
        current->next->prev = current->prev;
    }
    
    free(nodeToDelete);
    chain->length--;
    return 1;
}

/**
 * Display the DNA chain
 */
void displayDNAChain(DNAChain* chain) {
    if (chain->head == NULL) {
        printf("Empty DNA chain\n");
        return;
    }
    
    printf("DNA Chain (%d nucleotides): ", chain->length);
    
    DNANode* current = chain->head;
    int count = 0;
    
    while (current != NULL) {
        printf("%c", current->nucleotide);
        
        // Add a space after every 10 nucleotides for readability
        count++;
        if (count % 10 == 0 && current->next != NULL) {
            printf(" ");
        }
        
        current = current->next;
    }
    
    printf("\n");
}

/**
 * Create a complementary DNA chain
 * A pairs with T, G pairs with C
 */
DNAChain* complementDNAChain(DNAChain* chain) {
    DNAChain* complementChain = createDNAChain();
    
    DNANode* current = chain->head;
    while (current != NULL) {
        char complement;
        
        switch(current->nucleotide) {
            case 'A': complement = 'T'; break;
            case 'T': complement = 'A'; break;
            case 'G': complement = 'C'; break;
            case 'C': complement = 'G'; break;
            default: complement = 'N'; // Unknown nucleotide
        }
        
        appendNucleotide(complementChain, complement);
        current = current->next;
    }
    
    return complementChain;
}

/**
 * Validate if a character is a valid nucleotide (A, T, G, C)
 */
int validateNucleotide(char nucleotide) {
    nucleotide = toupper(nucleotide);
    return (nucleotide == 'A' || nucleotide == 'T' || 
            nucleotide == 'G' || nucleotide == 'C');
}

/**
 * Print help information
 */
void printHelp() {
    printf("\nDNA Chain CLI Lab Commands:\n");
    printf("---------------------------\n");
    printf("  append X    - Append nucleotide X to the end of the chain\n");
    printf("  insert X P  - Insert nucleotide X at position P\n");
    printf("  delete P    - Delete nucleotide at position P\n");
    printf("  display     - Display the current DNA chain\n");
    printf("  complement  - Create and display the complementary DNA chain\n");
    printf("  reverse     - Reverse the current DNA chain\n");
    printf("  search SEQ  - Search for a sequence in the chain\n");
    printf("  load FILE   - Load DNA chain from a file\n");
    printf("  save FILE   - Save DNA chain to a file\n");
    printf("  clear       - Clear the current DNA chain\n");
    printf("  length      - Display the length of the chain\n");
    printf("  help        - Display this help information\n");
    printf("  exit/quit   - Exit the program\n");
    printf("\nNotes:\n");
    printf("- Valid nucleotides are A, T, G, and C\n");
    printf("- Positions are 0-indexed (0 is the first position)\n");
}

/**
 * Load DNA chain from a file
 * Returns 1 on success, 0 on failure
 */
int loadFromFile(DNAChain* chain, const char* filename) {
    FILE* file = fopen(filename, "r");
    if (file == NULL) {
        return 0;
    }
    
    // Clear the current chain
    freeDNAChain(chain);
    chain = createDNAChain();
    
    char nucleotide;
    while ((nucleotide = fgetc(file)) != EOF) {
        if (validateNucleotide(nucleotide)) {
            appendNucleotide(chain, toupper(nucleotide));
        }
    }
    
    fclose(file);
    return 1;
}

/**
 * Save DNA chain to a file
 * Returns 1 on success, 0 on failure
 */
int saveToFile(DNAChain* chain, const char* filename) {
    FILE* file = fopen(filename, "w");
    if (file == NULL) {
        return 0;
    }
    
    DNANode* current = chain->head;
    while (current != NULL) {
        fputc(current->nucleotide, file);
        current = current->next;
    }
    
    fclose(file);
    return 1;
}

/**
 * Search for a pattern in the DNA chain
 */
void searchPattern(DNAChain* chain, const char* pattern) {
    int patternLength = strlen(pattern);
    
    if (patternLength == 0) {
        printf("Empty search pattern\n");
        return;
    }
    
    if (patternLength > chain->length) {
        printf("Pattern not found (pattern is longer than the chain)\n");
        return;
    }
    
    // Validate pattern contains only valid nucleotides
    for (int i = 0; i < patternLength; i++) {
        if (!validateNucleotide(pattern[i])) {
            printf("Invalid nucleotide in search pattern\n");
            return;
        }
    }
    
    int found = 0;
    int position = 0;
    
    DNANode* current = chain->head;
    while (current != NULL && position <= chain->length - patternLength) {
        // Check if pattern matches at current position
        int matches = 1;
        DNANode* temp = current;
        
        for (int i = 0; i < patternLength; i++) {
            if (temp->nucleotide != pattern[i]) {
                matches = 0;
                break;
            }
            temp = temp->next;
        }
        
        if (matches) {
            if (!found) {
                printf("Pattern '%s' found at position(s): ", pattern);
            } else {
                printf(", ");
            }
            printf("%d", position);
            found = 1;
        }
        
        current = current->next;
        position++;
    }
    
    if (!found) {
        printf("Pattern '%s' not found in the chain\n", pattern);
    } else {
        printf("\n");
    }
}

/**
 * Reverse the DNA chain
 */
void reverseChain(DNAChain* chain) {
    if (chain->head == NULL || chain->head == chain->tail) {
        // Empty chain or single node, nothing to reverse
        return;
    }
    
    DNANode* current = chain->head;
    DNANode* temp = NULL;
    
    // Swap next and prev pointers for all nodes
    while (current != NULL) {
        temp = current->prev;
        current->prev = current->next;
        current->next = temp;
        current = current->prev; // Move to the next node (which is now prev)
    }
    
    // Swap head and tail pointers
    temp = chain->head;
    chain->head = chain->tail;
    chain->tail = temp;
}





/* Features of the DNA Chain CLI:

Basic Operations:

Append nucleotides to the end of the chain
Insert nucleotides at specific positions
Delete nucleotides from specific positions
Display the current DNA chain


Advanced Operations:

Generate complementary DNA chains (A pairs with T, G pairs with C)
Reverse the DNA chain
Search for specific patterns in the chain
Calculate the length of the chain


File Operations:

Load DNA sequences from files
Save DNA sequences to files


Data Validation:

Validates that only proper nucleotides (A, T, G, C) are added
Checks that operations are performed at valid positions



The implementation uses a doubly-linked list for efficient operations in both directions. Each node in the list contains a nucleotide and pointers to both the next and previous nodes.*/
